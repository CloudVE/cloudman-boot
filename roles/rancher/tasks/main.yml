---

- name: Decide on password
  set_fact:
    rancher_password: "{{ random_pwd }}"
    using_random_pwd: true
  when: rancher_password == ''

- debug:
    msg: "Using rancher pwd {{ rancher_password }}"
    verbosity: 2

- name: Pull and run the Rancher/server container
  docker_container:
      name: "{{ rancher_name }}"
      image: rancher/rancher:{{ rancher_version }}
      restart_policy: unless-stopped
      ports:
        - "{{ rancher_port_80}}:80"
        - "{{ rancher_port }}:443"

- debug: msg="Using rancher_server address {{ rancher_server }}"

- name: Setup login
  uri:
    url: "https://{{ rancher_server }}:{{ rancher_port }}/v3-public/localProviders/local?action=login"
    method: POST
    body_format: json
    body:
      username: admin
      password: admin
    validate_certs: no
    status_code: 201
    return_content: yes
  ignore_errors: yes
  register: login_response
  until: login_response['status'] | default(0) == 201
  retries: 5
  delay: 10

- name: Set current admin password
  set_fact:
    rpwd: admin
    token: "{{ login_response.json.token }}"
  when: login_response is succeeded

- name: Re-setup login
  uri:
    url: "https://{{ rancher_server }}:{{ rancher_port }}/v3-public/localProviders/local?action=login"
    method: POST
    body_format: json
    body:
      username: admin
      password: "{{ rancher_password }}"
    validate_certs: no
    status_code: 201
    return_content: yes
  register: login_response
  when: login_response is failed

- name: Set current admin password
  set_fact:
    rpwd: "{{ rancher_password }}"
    token: "{{ login_response.json.token }}"
  when: rpwd is undefined

- name: Change password
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/users?action=changepassword
    method: POST
    body_format: json
    body:
      currentPassword: "{{ rpwd }}"
      newPassword: "{{ rancher_password }}"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no

# Not used but left in case we need it one day
# - name: Create an API key
#   uri:
#     url: https://{{ rancher_server }}:{{ rancher_port }}/v3/token
#     method: POST
#     body_format: json
#     body:
#       type: token
#       description: cloudman-boot ansible
#       ttl: 3600000  # Expires in 1 hour
#     headers:
#       Authorization: Bearer {{ token }}
#     validate_certs: no
#     status_code: 201
#   register: api_token

- name: Configure server URL
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/settings/server-url
    method: PUT
    body_format: json
    body:
      name: server-url
      type: setting
      value: "https://{{ rancher_server }}:{{ rancher_port }}"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no

- name: Check if cluster already exists
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/clusters?name={{ cm_cluster_name }}
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
  register: clusters

- name: Store existing cluster id
  set_fact:
    cluster_id: "{{ clusters.json.data[0].id }}"
  when: clusters.json.data | length > 0

- name: Create a (cloud) cluster
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/cluster
    method: POST
    body_format: json
    body:
      type: cluster
      name: "{{ cm_cluster_name }}"
      rancherKubernetesEngineConfig:
        ignoreDockerVersion: true
        ingress:
          provider: nginx
          type: ingressConfig
        cloudProvider:
          name: "{{ kube_cloud_provider }}"
          customCloudProvider: |-
            {{ kube_cloud_conf | b64decode }}
        services:
          type: "/v3/schemas/rkeConfigServices"
          kubeApi:
            type: "/v3/schemas/kubeAPIService"
            extraArgs:
              feature-gates: "TTLAfterFinished=true"
          kubeController:
            type: "/v3/schemas/kubeControllerService"
            extraArgs:
              feature-gates: "TTLAfterFinished=true"
              # for GCP: https://github.com/projectcalico/canal/issues/74
              configure-cloud-routes: "{{ true if kube_cloud_provider == 'gce' else false }}"
          kubelet:
            type: "/v3/schemas/kubeletService"
            extraArgs:
              feature-gates: "TTLAfterFinished=true"
          kubeproxy:
            type: "/v3/schemas/kubeproxyService"
            extraArgs:
              feature-gates: "TTLAfterFinished=true"
          scheduler:
            type: "/v3/schemas/schedulerService"
            extraArgs:
              feature-gates: "TTLAfterFinished=true"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  register: cluster
  when: not cluster_id is defined and kube_cloud_provider

- name: Store new cloud cluster id
  set_fact:
    cluster_id: "{{ cluster.json.id }}"
  when: cluster is not skipped

- name: Create a (local) cluster
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/cluster
    method: POST
    body_format: json
    body:
      type: cluster
      name: "{{ cm_cluster_name }}"
      rancherKubernetesEngineConfig:
        ignoreDockerVersion: true
        ingress:
          provider: nginx
          type: ingressConfig
        services:
          type: "/v3/schemas/rkeConfigServices"
          kubeApi:
            type: "/v3/schemas/kubeAPIService"
            extraArgs:
              feature-gates: "TTLAfterFinished=true"
          kubeController:
            type: "/v3/schemas/kubeControllerService"
            extraArgs:
              feature-gates: "TTLAfterFinished=true"
          kubelet:
            type: "/v3/schemas/kubeletService"
            extraArgs:
              feature-gates: "TTLAfterFinished=true"
          kubeproxy:
            type: "/v3/schemas/kubeproxyService"
            extraArgs:
              feature-gates: "TTLAfterFinished=true"
          scheduler:
            type: "/v3/schemas/schedulerService"
            extraArgs:
              feature-gates: "TTLAfterFinished=true"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  register: cluster
  when: not cluster_id is defined and not kube_cloud_provider

- name: Store new local cluster id
  set_fact:
    cluster_id: "{{ cluster.json.id }}"
  when: cluster is not skipped

# Special handling for AWS
# https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/aws#tagging-amazon-resources
# There is a possible race condition here if the cluster initialization completes before the tag
# is set, which seems unlikely. However, in such an event, we would have to decompose setting the
# cloudProvider into two steps. First create the cluster without the cloudProvider configured,
# then, obtain the cluster id and set the instance tag and finally update the cluster again with
# the correct cloudProvider configured.
- name: Set aws instance tag
  script: set_aws_instance_tag.py {{ cluster_id }}
  environment:
    CM_INITIAL_CLUSTER_DATA: "{{ cm_initial_cluster_data }}"
  when: kube_cloud_provider == "aws"

- name: Generate cluster registration token and extract node command
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/clusterregistrationtoken
    method: POST
    body_format: json
    body:
      type: clusterRegistrationToken
      clusterId: "{{ cluster_id }}"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  register: node_command

- name: Extract node command
  set_fact:
    node_command: "{{ node_command.json.nodeCommand }}"

- name: Remove sudo from the node command
  set_fact:
    node_command: "{{ node_command | replace('sudo ', '') }}"

- debug: msg="Node cmd is {{ node_command }} {{ node_command }} {{ rancher_master_etcd }} {{ rancher_master_controlplane }} {{ rancher_master_as_worker }}"

- name: Get current cluster status
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/clusters/{{ cluster_id }}
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
  register: cluster_state1

- name: Add master as a node
  command: "{{ node_command }} {{ rancher_master_etcd }} {{ rancher_master_controlplane }} {{ rancher_master_as_worker }}"
  when: cluster_state1.json.state == "provisioning"

- name: Wait for the cluster to become active
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/clusters/{{ cluster_id }}
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
  register: cluster_state_dbg

- name: Wait for the cluster to become active
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/clusters/{{ cluster_id }}
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
  register: cluster_state2
  until: '"active" in cluster_state2.json.state'
  retries: 50
  delay: 15

- name: Add provider block storage class
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port}}/v3/clusters/{{ cluster_id }}/storageclass
    method: POST
    body_format: json
    body:
      type: "storageClass"
      name: "ebs-provisioner"
      reclaimPolicy: "Delete"
      allowVolumeExpansion: true
      provisioner: "kubernetes.io/aws-ebs"
      parameters:
        type: "gp2"
        encrypted: "false"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  when: kube_cloud_provider == "aws"

- name: Add provider block storage class
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port}}/v3/clusters/{{ cluster_id }}/storageclass
    method: POST
    body_format: json
    body:
      type: "storageClass"
      name: "ebs-provisioner"
      reclaimPolicy: "Delete"
      allowVolumeExpansion: true
      provisioner: "kubernetes.io/azure-disk"
      parameters:
        kind: "shared"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  when: kube_cloud_provider == "azure"

- name: Add provider block storage class
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port}}/v3/clusters/{{ cluster_id }}/storageclass
    method: POST
    body_format: json
    body:
      type: "storageClass"
      name: "ebs-provisioner"
      reclaimPolicy: "Delete"
      allowVolumeExpansion: true
      provisioner: "kubernetes.io/gce-pd"
      parameters:
        type: "pd-ssd"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  when: kube_cloud_provider == "gce"

- name: Add provider block storage class
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port}}/v3/clusters/{{ cluster_id }}/storageclass
    method: POST
    body_format: json
    body:
      type: "storageClass"
      name: "ebs-provisioner"
      reclaimPolicy: "Delete"
      allowVolumeExpansion: true
      provisioner: "kubernetes.io/cinder"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  when: kube_cloud_provider == "openstack"

- name: Check if cloudman app is in the catalog already
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/catalogs?name={{ cm_catalog_name }}
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
  register: cm_helm_app

- name: Add custom Helm repos to the Rancher catalog
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/catalog
    method: POST
    body_format: json
    body:
      branch: "{{ item.branch }}"
      kind: helm
      name: "{{ item.app_name }}"
      type: catalog
      url: "{{ item.app_url }}"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  when: cm_helm_app.json.data | length == 0
  with_items:
    - { app_name: "{{ galaxy_catalog_name }}", app_url: 'https://github.com/CloudVE/helm-charts.git', branch: 'master' }
  loop_control:  # Rancher's concurrency here does not keep up without sleep
    pause: 10

- name: Get project info
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/projects?clusterId={{ cluster_id }}
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
  register: project

- name: Set project id
  set_fact:
    project_id: "{{ project.json.data[0].id }}"
    system_project_id: "{{ project.json.data[1].id }}"

- name: Check if CloudMan namespace already exists
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/cluster/{{ cluster_id }}/namespaces?name={{ cm_namespace_name }}
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
  register: cm_ns

- name: Add CloudMan namespace
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/clusters/{{ cluster_id }}/namespace
    method: POST
    body_format: json
    body:
      name: "{{ cm_namespace_name }}"
      type: namespace
      projectId: "{{ project_id }}"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  when: cm_ns.json.data | length == 0

- name: Add kube-system namespace to the Default project
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/cluster/{{ cluster_id }}/namespaces/kube-system
    method: PUT
    body_format: json
    body:
      baseType: namespace
      id: kube-system
      name: kube-system
      projectId: "{{ project_id }}"
      type: namespace
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no

- name: Fetch kubectl config from Rancher
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/clusters/{{ cluster_id }}?action=generateKubeconfig
    method: POST
    headers:
      Content-Type: application/json
      Authorization: Bearer {{ token }}
    validate_certs: False
  register: kubectl_config

- name: Make sure ~/.kube dir exist
  file:
    path: ~/.kube
    state: directory

- name: Save kubectl config
  copy:
    content: "{{ kubectl_config.json.config }}"
    dest: ~/.kube/config

- name: Setup service account
  shell: /usr/local/bin/kubectl create serviceaccount --namespace kube-system tiller && /usr/local/bin/kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller

- name: Init Helm
  shell: /usr/local/bin/helm init --service-account tiller

- name: Wait for tiller pod to start...
  command: /usr/local/bin/helm list
  register: tiller_ready
  until: tiller_ready.rc == 0
  retries: 30
  delay: 2

- name: Add CloudVE Helm repo
  shell: /usr/local/bin/helm repo add galaxyproject https://raw.githubusercontent.com/cloudve/helm-charts/master/

- name: Update Helm repos
  shell: /usr/local/bin/helm repo update

- name: Fallback to hostPath provisioner when no cloud provider is set
  shell: /usr/local/bin/kubectl apply -f /tmp/cm-boot/roles/rancher/files/hostPath_storageClass.yaml
  when: not kube_cloud_provider

# Persistent Volumes are being added instead above
- name: Check if nfs-provisioner app has been added
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/project/{{ project_id }}/apps?name=nfs-provisioner
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
  register: nfs_app

- name: Add nfs-provisioner app
  uri:
    url: https://{{ rancher_server }}:{{ rancher_port }}/v3/projects/{{ project_id }}/app
    method: POST
    body_format: json
    body:
      name: "nfs-provisioner"
      targetNamespace: "{{ cm_namespace_name }}"
      type: "app"
      prune: false
      projectId: "{{ project_id }}"
      externalId: "catalog://?catalog=library&template=nfs-provisioner&version=0.2.2"
      answers:
        defaultImage: "true"
        image.repository: "quay.io/kubernetes_incubator/nfs-provisioner"
        image.tag: "v1.0.9"
        persistence.enabled: "true"
        persistence.hostPath: "/nfs"
        persistence.size: "{{ cm_initial_storage_size }}"
        persistence.storageClass: "ebs-provisioner"
        storageClass.allowVolumeExpansion: "true"
        storageClass.create: "true"
        storageClass.defaultClass: "true"
        storageClass.reclaimPolicy: "Delete"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  when: nfs_app.json.data | length == 0

- name: Add Kubernetes Dashboard app
  uri:
    url: https://{{ rancher_server }}:4430/v3/projects/{{ system_project_id }}/app
    method: POST
    body_format: json
    body:
      name: "kubernetes-dashboard"
      targetNamespace: "kube-system"
      type: "app"
      prune: false
      projectId: "{{ system_project_id }}"
      externalId: "catalog://?catalog=library&template=kubernetes-dashboard&version=1.2.0"
      answers:
        defaultImage: "true"
        image.repository: "rancher/kubernetes-dashboard-amd64"
        image.tag: "v1.10.1"
        enableSkipLogin: "false"
        rbac.clusterAdminRole: "true"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  ignore_errors: true

- name: Add cert-manager app
  uri:
    url: https://{{ rancher_server }}:4430/v3/projects/{{ project_id }}/app
    method: POST
    body_format: json
    body:
      name: "cert-manager"
      targetNamespace: "{{ cm_namespace_name }}"
      type: "app"
      prune: false
      projectId: "{{ project_id }}"
      externalId: "catalog://?catalog=library&template=cert-manager&version=v0.5.2"
      answers:
        defaultImage: "true"
        image.repository: "quay.io/jetstack/cert-manager-controller"
        image.tag: "v0.5.2"
        clusterissuerEnabled: "true"
        ingressShim.defaultIssuerName: "letsencrypt-prod"
        letsencrypt.email: "admin@{{ rancher_server }}"
        createCustomResource: "true"
        webhook.enabled: "false"
    headers:
      Authorization: Bearer {{ token }}
    validate_certs: no
    status_code: 201
  ignore_errors: true

- name: Create CloudMan chart template file
  template:
    src: cm_chart_values.yml.j2
    dest: /tmp/template_cm_chart_values.j2

- name: Render CloudMan chart custom values file
  template:
    src: /tmp/template_cm_chart_values.j2
    dest: /tmp/cm_chart_values.yml

- name: Helm install CloudMan
  command: >
    /usr/local/bin/helm install galaxyproject/cloudman
    --name "cloudman"
    --namespace "{{ cm_namespace_name }}"
    --version "{{ cm_helm_version }}"
    -f /tmp/cm_chart_values.yml
  ignore_errors: true
  when: cm_skip_cloudman is not defined or not (cm_skip_cloudman|bool)

# - helm:
#     host: localhost
#     name: cloudman
#     namespace: "{{ cm_namespace_name }}"
#     chart:
#       name: cloudman
#       version: "{{ cm_helm_version }}"
#       source:
#         type: repo
#         location: https://raw.githubusercontent.com/CloudVE/helm-charts/master/
#     values:
#       cloudlaunch.cloudlaunch-server.extra_env.rancher_url: "https://{{ rancher_server }}:{{ rancher_port }}"
#       cloudlaunch.cloudlaunch-server.extra_env.rancher_api_key: "{{ token }}"
#       cloudlaunch.cloudlaunch-server.extra_env.rancher_cluster_id: "{{ cluster_id }}"
#       cloudlaunch.cloudlaunch-server.extra_env.rancher_project_id: "{{ project_id }}"
#       cloudlaunch.cloudlaunch-server.extra_env.rancher_node_command: "{{ node_command }} --worker"
#       cloudlaunch.cloudlaunch-server.extra_env.cm_bootstrap_data: "{{ cm_bootstrap_data|default('') }}"
#       cloudlaunch.cloudlaunch-server.admin_password: "{{ rancher_password }}"
#       keycloak.keycloak.password: "{{ rancher_password }}"
#       global.domain: "{{ rancher_server }}"

# - name: Helm install CloudMan
#   helm:
#     host: localhost
#     name: cloudman
#     namespace: "{{ cm_namespace_name }}"
#     chart:
#       name: cloudman
#       version: "{{ cm_helm_version }}"
#       source:
#         type: repo
#         location: https://raw.githubusercontent.com/CloudVE/helm-charts/master/
#     values:
#       cloudlaunch.cloudlaunch-server.extra_env.rancher_url: "https://{{ rancher_server }}:{{ rancher_port }}"
#       cloudlaunch.cloudlaunch-server.extra_env.rancher_api_key: "{{ token }}"
#       cloudlaunch.cloudlaunch-server.extra_env.rancher_cluster_id: "{{ cluster_id }}"
#       cloudlaunch.cloudlaunch-server.extra_env.rancher_project_id: "{{ project_id }}"
#       cloudlaunch.cloudlaunch-server.extra_env.rancher_node_command: "{{ node_command }} --worker"
#       cloudlaunch.cloudlaunch-server.extra_env.cm_bootstrap_data: "{{ cm_bootstrap_data|default('') }}"
#       cloudlaunch.cloudlaunch-server.admin_password: "{{ rancher_password }}"
#       keycloak.keycloak.password: "{{ rancher_password }}"
#       global.domain: "{{ rancher_server }}"

# # Adding CloudMan is being done via Helm directly
# - name: Check if CloudMan app has been added
#   uri:
#     url: https://{{ rancher_server }}:{{ rancher_port }}/v3/project/{{ project_id }}/apps?name=cloudman
#     headers:
#       Authorization: Bearer {{ token }}
#     validate_certs: no
#   register: cm_app

# - name: Launch CloudMan app
#   uri:
#     url: https://{{ rancher_server }}:{{ rancher_port }}/v3/projects/{{ project_id }}/app
#     method: POST
#     body_format: json
#     body:
#       name: cloudman
#       targetNamespace: "{{ cm_namespace_name }}"
#       type: app
#       prune: false
#       projectId: "{{ project_id }}"
#       externalId: "catalog://?catalog={{ galaxy_catalog_name }}&template=cloudman&version={{ cm_helm_version }}"
#       answers:
#         cloudlaunch.cloudlaunch-server.extra_env.rancher_url: "https://{{ rancher_server }}:{{ rancher_port }}"
#         cloudlaunch.cloudlaunch-server.extra_env.rancher_api_key: "{{ token }}"
#         cloudlaunch.cloudlaunch-server.extra_env.rancher_cluster_id: "{{ cluster_id }}"
#         cloudlaunch.cloudlaunch-server.extra_env.rancher_project_id: "{{ project_id }}"
#         cloudlaunch.cloudlaunch-server.extra_env.rancher_node_command: "{{ node_command }} --worker"
#         cloudlaunch.cloudlaunch-server.extra_env.cm_bootstrap_data: "{{ cm_bootstrap_data|default('') }}"
#         cloudlaunch.cloudlaunch-server.admin_password: "{{ rancher_password }}"
#         keycloak.keycloak.password: "{{ rancher_password }}"
#         global.domain: "{{ rancher_server }}"
#     headers:
#       Authorization: Bearer {{ token }}
#     validate_certs: no
#     status_code: 201
#   when: cm_app.json.data | length == 0

# - name: Check if Galaxy namespace already exists
#   uri:
#     url: https://{{ rancher_server }}:{{ rancher_port }}/v3/cluster/{{ cluster_id }}/namespaces?name={{ galaxy_namespace_name }}
#     headers:
#       Authorization: Bearer {{ token }}
#     validate_certs: no
#   register: gxy_ns

# - name: Add Galaxy namespace
#   uri:
#     url: https://{{ rancher_server }}:{{ rancher_port }}/v3/clusters/{{ cluster_id }}/namespace
#     method: POST
#     body_format: json
#     body:
#       name: "{{ galaxy_namespace_name }}"
#       type: namespace
#       projectId: "{{ project_id }}"
#     headers:
#       Authorization: Bearer {{ token }}
#     validate_certs: no
#     status_code: 201
#   when: gxy_ns.json.data | length == 0

# - name: Check if Galaxy app has been added
#   uri:
#     url: "https://{{ rancher_server }}:{{ rancher_port }}/v3/project/{{ project_id }}/apps?name={{ galaxy_chart_name }}"
#     headers:
#       Authorization: Bearer {{ token }}
#     validate_certs: no
#   register: gxy_app

# - name: Launch Galaxy app
#   uri:
#     url: https://{{ rancher_server }}:{{ rancher_port }}/v3/projects/{{ project_id }}/app
#     method: POST
#     body_format: json
#     body:
#       name: galaxy
#       targetNamespace: "{{ galaxy_namespace_name }}"
#       type: app
#       prune: false
#       projectId: "{{ project_id }}"
#       externalId: "catalog://?catalog={{ galaxy_catalog_name }}&template={{ galaxy_chart_name }}&version={{ galaxy_helm_version }}"
#       answers:
#         admin.email: "admin@galaxyproject.org"
#         admin.password: "{{ rancher_password }}"
#         admin.username: "admin"
#         ingress.path: "/galaxy"
#     headers:
#       Authorization: Bearer {{ token }}
#     validate_certs: no
#     status_code: 201
#   when: gxy_app.json.data | length == 0

# - name: Disable the default library catalog
#   uri:
#     url: https://{{ rancher_server }}:{{ rancher_port }}/v3/catalogs/library
#     method: DELETE
#     headers:
#       Authorization: Bearer {{ token }}
#     validate_certs: no

- name: Compose random pwd access doc
  set_fact:
    svc_access_line: "Login to any of these services as user 'admin', using password '{{ rancher_password }}'"
  when: using_random_pwd is defined and using_random_pwd

- name: Compose supplied pwd access doc
  set_fact:
    svc_access_line: "Login to any of these services as user 'admin', using the password you supplied."
  when: using_random_pwd is not defined

- name: Login to KeyCloak
  uri:
    url: "https://{{ rancher_server }}/auth/realms/master/protocol/openid-connect/token"
    method: POST
    body_format: form-urlencoded
    body:
      client_id: admin-cli
      grant_type: password
      username: admin
      password: "{{ rancher_password }}"
    validate_certs: no
    return_content: yes
  register: kc_login_response
  until: kc_login_response['status']|default(0) == 200
  retries: 30
  delay: 10

- name: Set KeyCloak Token
  set_fact:
    kc_token: "{{ kc_login_response.json.access_token }}"

- name: Create KeyCloak SAML Client
  uri:
    url: "https://{{ rancher_server }}/auth/admin/realms/master/clients"
    method: POST
    body_format: json
    body:
      clientId: "https://{{ rancher_server }}:{{ rancher_port }}/v1-saml/keycloak/saml/metadata"
      name: "rancher"
      protocol: "saml"
      frontchannelLogout: false
      redirectUris: ["https://{{ rancher_server }}:{{ rancher_port }}/v1-saml/keycloak/saml/acs"]
      attributes: { "saml.authnstatement": false, "saml.client.signature": false, "saml.force.post.binding": false, "saml.server.signature": true}
    validate_certs: no
    status_code: 201
    headers:
      Authorization: Bearer {{ kc_token }}
    return_content: yes
  register: kc_rancher_client_resp
  retries: 5
  delay: 10

- name: Create cn mapping
  uri:
    url: "{{ kc_rancher_client_resp.location }}/protocol-mappers/models"
    method: POST
    body_format: json
    body:
      config:
        user.attribute: "username"
        friendly.name: ""
        attribute.name: "cn"
        attribute.nameformat: "Basic"
      name: "username to cn"
      protocol: "saml"
      protocolMapper: "saml-user-property-mapper"
    validate_certs: no
    status_code: 201
    headers:
      Authorization: Bearer {{ kc_token }}
  retries: 5
  delay: 10

- name: Create uid mapping
  uri:
    url: "{{ kc_rancher_client_resp.location }}/protocol-mappers/models"
    method: POST
    body_format: json
    body:
      config:
        user.attribute: "username"
        friendly.name: ""
        attribute.name: "uid"
        attribute.nameformat: "Basic"
      name: "username to uid"
      protocol: "saml"
      protocolMapper: "saml-user-property-mapper"
    validate_certs: no
    status_code: 201
    headers:
      Authorization: Bearer {{ kc_token }}
  retries: 5
  delay: 10

- name: Create displayName mapping
  uri:
    url: "{{ kc_rancher_client_resp.location }}/protocol-mappers/models"
    method: POST
    body_format: json
    body:
      config:
        user.attribute: "firstName"
        friendly.name: ""
        attribute.name: "displayName"
        attribute.nameformat: "Basic"
      name: "firstName to displayName"
      protocol: "saml"
      protocolMapper: "saml-user-property-mapper"
    validate_certs: no
    status_code: 201
    headers:
      Authorization: Bearer {{ kc_token }}
  retries: 5
  delay: 10

- name: Create Groups mapping
  uri:
    url: "{{ kc_rancher_client_resp.location }}/protocol-mappers/models"
    method: POST
    body_format: json
    body:
      config:
        attribute.name: "memberOf"
        attribute.nameformat: "Basic"
        friendly.name: ""
        full.path: false
        single: true
      name: "Groups"
      protocol: "saml"
      protocolMapper: "saml-group-membership-mapper"
    validate_certs: no
    status_code: 201
    headers:
      Authorization: Bearer {{ kc_token }}
  retries: 5
  delay: 10

#https://rancher.com/docs/rancher/v2.x/en/admin-settings/authentication/keycloak/#keycloak-6-0-0-idpssodescriptor-missing-from-options
- name: Get SAML Metadata IDPSSODescriptor
  uri:
    url: "https://{{ rancher_server }}/auth/realms/master/protocol/saml/descriptor"
    method: GET
    validate_certs: no
    headers:
      Authorization: Bearer {{ kc_token }}
    return_content: yes
  register: idp_metadata
  retries: 5
  delay: 10

- name: Generate a key
  openssl_privatekey:
    path: /tmp/cm-boot/ansible-rancher.pem
    size: 2048

- name: Generate CSR
  openssl_csr:
    path: /tmp/cm-boot/ansible-rancher.csr
    privatekey_path: /tmp/cm-boot/ansible-rancher.pem
    common_name: ansible-rancher

- name: Generate a Self Signed OpenSSL certificate
  openssl_certificate:
    path: /tmp/cm-boot/ansible-rancher.crt
    privatekey_path: /tmp/cm-boot/ansible-rancher.pem
    csr_path: /tmp/cm-boot/ansible-rancher.csr
    provider: selfsigned

- name: Set key and certificate
  set_fact:
    rancher_key: "{{ lookup('file', '/tmp/cm-boot/ansible-rancher.pem') }}"
    rancher_cert: "{{ lookup('file', '/tmp/cm-boot/ansible-rancher.crt') }}"

- name: Login to Rancher
  uri:
    url: "https://{{ rancher_server }}:{{ rancher_port }}/v3-public/localProviders/local?action=login"
    method: POST
    body_format: json
    body:
      username: admin
      password: "{{ rancher_password }}"
    validate_certs: no
    status_code: 201
    return_content: yes
  register: rancher_login
  retries: 5
  delay: 10

- name: Set Rancher Token
  set_fact:
    ra_token: "{{ rancher_login.json.token }}"

- name: Setup Rancher External Auth
  uri:
    url: "https://{{ rancher_server }}:{{ rancher_port }}/v3/keyCloakConfigs/keycloak"
    method: PUT
    validate_certs: no
    body_format: json
    body:
      accessMode: "required"
      actions: { "disable": "https://{{ rancher_server }}:{{ rancher_port }}/v3/keyCloakConfigs/keycloak?action=disable", "testAndEnable": "https://{{ rancher_server }}:{{ rancher_port }}/v3/keyCloakConfigs/keycloak?action=testAndEnable" }
      allowedPrincipalIds: ["keycloak_user://admin"]
      baseType: "authConfig"
      displayNameField: "displayName"
      enabled: true
      groupsField: "memberOf"
      id: "keycloak"
      idpMetadataContent: '{{ idp_metadata.content | regex_replace("<EntitiesDescriptor ([^>]*)>\s+<EntityDescriptor", "<EntityDescriptor \1") | regex_replace("\n</EntitiesDescriptor>", "") }}'
      links: { "self": "https://{{ rancher_server }}:{{ rancher_port }}/v3/keyCloakConfigs/keycloak", "update": "https://{{ rancher_server }}:{{ rancher_port }}/v3/keyCloakConfigs/keycloak" }
      name: "keycloak"
      rancherApiHost: "https://{{ rancher_server }}:{{ rancher_port }}/"
      spCert: "{{ rancher_cert }}"
      spKey: "{{ rancher_key }}"
      type: "keyCloakConfig"
      uidField: "uid"
      userNameField: "cn"
    headers:
      Authorization: Bearer {{ ra_token }}
  retries: 5
  delay: 10

- name: Set default Rancher user role to admin
  uri:
    url: "https://{{ rancher_server }}:{{ rancher_port }}/v3/globalRoles/admin"
    method: PUT
    validate_certs: no
    body_format: json
    body:
      newUserDefault: true
    headers:
      Authorization: Bearer {{ ra_token }}
  retries: 5
  delay: 10

- name: Wait for CloudMan login to become accessible
  uri:
    url: "https://{{ rancher_server }}/cloudman/openid/openid/KeyCloak"
    method: GET
    validate_certs: no
  register: cm_available
  until: cm_available['status']|default(0) == 200
  retries: 60
  delay: 10
  when: cm_skip_cloudman is not defined or not (cm_skip_cloudman|bool)

- name: System help info
  debug:
    msg: |
      "The system has now been setup. Access CloudMan at https://{{ rancher_server }}/"
      ""
      "There are also these additional services available:"
      "  Rancher: https://{{ rancher_server }}:{{ rancher_port }}/"
      "  Keycloak: https://{{ rancher_server }}/auth/"
      ""
      "{{ svc_access_line }}"
      ""
      "For documentation and information about these services, see http://cloudve.org/"
...
